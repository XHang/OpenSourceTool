# 消息队列

## 一： 什么是消息队列

从通信说起，我想你肯定码过通信相关的代码吧，比如说TCP通信，比如说UDP通信.

它们有一个特点，就是

要么发送端和接受端同时在线，皆大欢喜，你能发送，我能收到

要么接受端挂掉了，如果是UDP的，发送端照样发送，如果是TCP的，发送端会报错

这带来一个潜在的问题

如果消息是很重要呢？

要么发出去被丢弃，要么发出去报错。不管是哪种情况，这个消息都是废了的。

同步的通信模型会出现这种问题。

这个时候，消息队列这个新东西的横空出世了。

它可以**帮发送端把消息存在一个队列中，等到接受端在线时再接受这个消息，提供了一种异步的通信方式**

它的**作用**也体现在这

## 二：消息队列的名词解释

- Producer：消息生产者，负责产生和发送消息到 Broker；也叫发送端

- Broker：消息处理中心。负责消息存储、确认、重试等，一般其中会包含多个 queue；

- > 如果说消息队列要有一个服务器，估计就是这货了

- Consumer：消息消费者，负责从 Broker 中获取消息，并进行相应处理；也叫接受端

## 三：消息队列的特性

1. 异步，减少了同步的等待时间

2. 松耦合，发送端和接口端只需指定消息队列的服务器，并与之通信即可，不用关心和对方通信的是人是狗

3. 分布式，说白了就是一个发送端，可以有多个接受端，一个接受端挂了，千千万万个接受端站起来了。

4. 可靠性，发送端发送消息过去后，消息一般都是存储在本地硬盘里面，直到接受端接受消息，可以选择继续存储或者直接销毁。

   在此之前，消息是安全的，即使发送端，接受端，服务器全挂掉。重启后还是能取到消息的

   ​

   ​



## 二 ：RabbitMQ

### 2.1 what is？

消息队列的提出只是一种思路，其实现还是要靠各位大佬去开发开源软件。

RabbitMQ就是其中一种，相对来说比较流行啦

### 2.2 相关名词和概念

消费者：就是接受队列消息的

生产者：就是发送消息到队列的

交换机制`exchange`:负责从生产者接受消息，并将消息推送到队列

**几个概念***

1. 消费者和生产者永远老死不能相见，只能通过第三方传递数据，RabbitMq就是做如此用

2. 生产者不知道自己发出的消息，收费者能不能收到。生产者只对RabbitMq负责

3. 消费者拿数据的方式只有一个，就是队列

   > 所以后面的广播实现中，消费者想收到广播消息，就需要弄一个临时的队列，专门接受广播消息



### 2.2怎么安装（rpm格式）

安装前提

`rabbitmq-server-3.7.3-1.el7` rpm安装包

`centos7 3.10.0-514.el7.x86_64` 操作系统

如果不满足前提，请查找其他解决方案

第一步：使用 ` rpm -ivh 安装包名` 安装	Rabbit软件

> 如果提示需要依赖的话。。
>
> 笔者就遇到两个依赖没装，分别是`erlang`和`socat`
>
> `socat`这个的话直接`yum install socat`即可成功安装
>
> `erlang` 这个稍微有点麻烦
>
> 两种解决方案
>
> 1. 添加repo仓库，直接`yum install erlang`  安装 ，但是repo仓库里面的erlang是古董级的
>
> 2. `erlang` 这个依赖可以通过EPEL仓库安装，但是据说仓库里面的依赖是比较古老的。
>
>    ........所以我用惨痛的经验告诉你们，仓库里面的源真是太古老了，版本要求不够。
>
>    ........所以我继续用惨痛的经验告诉你们，从源代码编译erlang简直丧心病狂，各位对自己能力有信心的，亦或是抖S的，欢迎尝试，成功了一定要告诉我。。。
>
>    .......所以如果你的系统如果是centos7的，恭喜你了。
>
>    RabbitMQ官网也是知道erlang安装的依赖太变态了，提供了一个专用的安装包，仅为RabbitMQ而用
>
>    你不用安装什么鬼依赖了
>
>    当然，不提供`OpenSSL/libcrypto`这个依赖，你需要自己安装。嘛，出来混，总是要还的
>
>    进入这个地址看下吧
>
>    `http://www.rabbitmq.com/install-rpm.html`
>
>    看看`(http://www.rabbitmq.com/install-rpm.html#install-erlang)`

第二步：恭喜你打败第一关的大BOSS了，接下来

安装后的RabbitMQ默认不会开启守护线程，如果想在系统启动时开启守护线程

用root用户执行此命令`chkconfig rabbitmq-server on`

好了，安装完毕。以上。

### 2.4 启动，停止RabbitMQ的Server

启动server：`service rabbitmq-server start`

停止server：`service rabbitmq-server stop`

### 2.5 配置RabbitMQ服务

系统启动时，以管理员身份启动应用程序

`chkconfig rabbitmq-server on`

> 创建RabbitMQ 服务



### 2.6 端口访问

确保可以越过防火墙访问到以下端口

`4369`   `5672`  `25672` `15672` `61613, 61614` `1883, 8883` `15674` `15675` 

至于原因，我不说，你们也应该知道的吧

当然，这些端口也可以更改的，自己找文档吧

  

### 2.7: 默认用户访问

未配置的情况下，默认Rabbit会使用

用户名：`guest`

密码 : `guest`

来创建一个用户

这个用户只能在本地回环地址访问RabbitMQ的后台管理页面时可用。

外网用不了这个用户，所以如果你想通过外网访问到后台管理页面

得赶紧去创建一个可用的用户

详情请查看访问控制

### 2.8 访问控制

首先这里要定义一下认证和授权

这两者通常会被混淆，这里必须理清楚一下

认证是指识别用户是谁

授权是指确定用户能做什么，不能做什么



关于访问控制。

在RabbitMQ Server开始启动时并检测到数据库未初始化或者已被删除的话，就会使用下列信息初始化新的数据库

一个虚拟主机名为`/`

用户名为`guest`密码 为`guest`被授予虚拟主机的所有权限

该用户只能通过本地回环地址访问到服务器，这是通过配置文件`loopback_users` 项进行配置的

如果你想让guest用户在任何地址上都可以登陆连接到服务器，在配置文件里面，把这项改一下

`loopback_users = none`

### 2.9 相关位置

#### 2.9.1 日志文件相关位置

假设您是在centos7，用rpm安装的rabbitMq，且没有自定义日志文件位置。

那您的日志文件位置，就在`vi /var/log/rabbitmq/`文件夹里面

如果不是，请参考官方文档的说明，人家说的很清楚了哦

`https://www.rabbitmq.com/relocate.html`

#### 2.9.2 配置文件位置

配置文件的位置要通过配置文件来看，一般来说，RabbitMq启动时，会在日志文件打上一行

```
 node           : rabbit@vm
 home dir       : /var/lib/rabbitmq
 config file(s) : (none)
 cookie hash    : OWrKEz6Wv/80qmgpmYITTg==
 log(s)         : /var/log/rabbitmq/rabbit@vm.log
                : /var/log/rabbitmq/rabbit@vm_upgrade.log
 database dir   : /var/lib/rabbitmq/mnesia/rabbit@vm
```

没错，config file后面跟着的，就是配置文件路径，但是你也看到了，我现在是none...(某些同学可能是NotFound)

这两种情况，都提醒你要自己创建配置文件了

1. 首先，要创建配置文件的路径应该和官网提到的配置文件路径的默认值一致

   如果你的按照过程与我一致，那么你的配置文件也应该要创建在

   ` /etc/rabbitmq/`

   至于文件的内容，如果你的rabbitMq的版本大于`3.7.0`则文件内容应该是`key=value`

   格式，也被称为`sysctl格式`

   有一个示例的配置文件

   `https://github.com/rabbitmq/rabbitmq-server/blob/v3.7.x/docs/rabbitmq.conf.example`

   有些高级配置，用简单的key—value配置难以配置，就可以配成`advanced.config`

   这个文件的内容和位置就不在此描述了，各位可以去官网看下

### 3.0 应用

首先要知道RabbitMq是什么，我们可以把它认为，它是一个邮局，它接受和转发二进制信息

RabbitMq有队列，可以把它认为是邮局里面的邮箱。

发送方可以把数据送到邮箱里面。

但是和传统的邮局不同，RabbitMq可以把这个邮箱里面的数据分发给很多接受者

对了，在RabbitMq里面，发送方被称为生产者，接受方被称为消费者

#### 3.1 点对点传输

程序目的:用Java实现一个发送方和接受方

代码在项目里面：`com.cxh.send.Sender`类的main方法以及`com.cxh.receive.Receiver`类的`main`方法

值得注意的是，如果你的rabbitMq刚安装，就火急火燎的在远程机测试这个`Hello_world`功能。

告诉你，必挂无疑。

会提示是说验证失败什么鬼的

为了能正常运行`Hello_world`功能,你需要查看访问控制那一章，把RabbitMq配置为`guest`

用户可以从远程IP访问。

当然，程序内也要设置好远程访问的用户名密码

用这个方法能体会到RabbitMq消息队列的几个特点

1. 异步接受，接受方可以不在线，发送方可以直接发送，当接受方在线时，就会接受到来自发送方的消息
2. 队列的含义，按什么顺序发送消息，就会以什么顺序接受消息

#### 3.2 工作队列(点对面传输)

在上一章中，我们探讨了一个简单的点对点的传输，但是这个功能太过简陋，根本不能应用于实际生产环境。

在生产环境中，更多的做法是将积压的工作发送到队列中，等到服务器有空闲时，再批次执行积压的工作。

当然，不止一个服务器执行工作，我们要做的是，一个生产者，多个消费者。

相关代码已加入肯德基豪华午餐。。。不对，项目中

生产者代码和消费者代码位于`com.cxh.workqueue`

特性有几个

1. 多消费者运行，将从生产者等量的获取到消息。每一个消息都只能有一个消费者接受。

   但是当消息很多时，就必须有多个消费者处理消息了

   > 举例子啊，有50个消息在队列中，但是只要两个消费者负责接送处理消息
   >
   > 那么它们最后执行的消息量可能都是25个，就是平均执行。

2. 当消费者挂了的时候，需要RabbitMq重新收回消息，把消息发给其他消费者。

   这需要稍微改下代码，基本要改的的地方有两个

   1. 把自动ack改为手动ack

   2. 当任务执行完时，发送一个确认消息告知RabbitMq我已经执完任务

   > 但是有一点容易犯的错误，就是消费者工作执行后，没有发送确认消息。
   >
   > 它的后果是致命的，消费者关闭后（等同于挂了）
   >
   > 没有被消息确认的消息将被重新发送给其他消费者去执行。
   >
   > 然后呢，消息就总是周而复始的在消费者和生产者之间传递，没有任何的消息确认使它终结使命
   >
   > 这会导致RabbitMq占的内存越来越大。
   >
   > 要想确认是这个问题，可以用这个命令查看未被消息确认的消息有哪些
   >
   > `sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged`

   3. 消息持久性，就是说，如果RabbitMq服务器也挂了咋办，消息不久丢了吗？

      当然，我们可以设置某一个队列，把队列里面的消息保存在磁盘中。

      哪怕RabbitMq一言不合就翘辫子了，重启后，仍然可以回忆之前的队列

      > 这需要声明一个新的队列，不能使用老队列，因为老的队列，他的属性不可更改

      另外，要说明一点的话，持久化不能每时每刻都发生的，在消息产生到持久化过程中。

      有一个空窗时间，在这段时间内，RabbitMq挂了，此间的消息也就没了。

      如果你的应用程序需要严格的把控空窗时间，可以使用`发布者确认`

      > 消息持久化本质上，是保存队列，队列里面的所有属性也会保存

   4. 公平派遣，为了避免RabbitMq偏爱将消息发送给某个消费者（使它不堪重负）。

      其他消费者悠哉悠哉。

      > 造成这个现象的原因是RabbitMq不知道那个消费者很忙。在他眼里，消费者都一个样。

      我们需要使用这个公平派遣，做法是酱紫的

      定义一个消费者最大并行处理数。

      当消费者有这个数目的消息还未处理完毕时，不再向它发送消息

      > 想偷懒，没门，我都知道你们手头上还有没有任务。

#### 3.3 订阅-发布模型(广播传输)

   这次我们将实现一个订阅，发布模型。

   > 也可以认为是一个简陋的日志系统
   >
   > 生产者负责发日志，一个接受者负责把日志保存到磁盘中
   >
   > 另一个接着负责把日志打印在控制台中

   在此之前，我们的消息基基本都是点对点传输的。也就是说，一个消息，只能由一个消费者接受

   订阅-发布模型则是一个消息，可以由多个消费者接受。

   > 消息队列的核心思想就是：生产者永远不会把消息直接发送给消费者
   >
   > 就好像房产中介永远不会希望找房子的和房东直接见面

   这次应用有几个特点

   1. 生产者需要声明一个交换机制（`exchange`）`fanout`，以表明如何处理队列中的消息

      这个交换机制负责将收到的信息，推送给所有与该`exchange`绑定的队列

      > 交换机制做的事情很简单，一方面接受生产者的信息，另一方面将消息推送到队列
      >
      > 在这其中，我们可以定义处理消息的行为，是
      >
      > 1. 应该附加到指定队列吗？（我们之前一直用的就是这个，它是默认的）
      > 2. 应该附加到许多队列吗？
      > 3. 应该丢弃消息吗？
      >
      > 值得注意的是，其实在此之前我们也是用过交换机制的啦，只不过用的是默认的
      >
      > 还记得这个代码吗
      >
      > `channel.basicPublish("", QUEUE_NAME, null, message.getBytes());`
      >
      > 发送端的代码
      >
      > 第一个参数就是交换名称，使用空串即表示使用的是默认的交换机制
      >
      > 默认的交换机制就是会把消息推给`routingKey`同名的队列
      >
      > 没错，`routingKey`就是第二个参数
      >
      > 另外，补充个知识
      >
      > `sudo rabbitmqctl list_exchanges`
      >
      > 可以列出所有可用的交换机制

   2. 消费者需要声明一个临时队列，这个临时队列将只用于接受广播消息。

      所以名字不重要，毕竟发送端广播消息时，没有必要知道听到的，都是些什么鬼东西

      > 但是名字还是需要的，用于绑定。

      所以不需要持久化存储，咋了，你听到村里的广播，还专门弄个收音机存起来

      所以广播后，这个临时队列需要删掉。毕竟它只用于接受广播，广播完毕后就毫无卵用了

      但是需要绑定到交换机制里面，以便交换机制能找到该队列，从而把消息广播给这个队列

   3. 消息不会异步传输，总是实时收取，类似于UDP，接收方不在线，这信息啊，就。没。了



      相关代码在项目的` com.cxh.pubsub`包里面

#### 3.4 路由

上一节中，我们讲了一个消息的订阅，发布模型。

但是在这个模型中，有一个缺点，就是消费者不能决定自己想要听什么广播。

这次我们来改进这个消息的订阅，发布模型，使某些消费者，只听到自己感兴趣的广播。

> 比如说，学生只需听到学校的广播。无需听到`澳门赌场上线啦`之类乱七八糟的广播

要达到这一点，我们需要以下概念

路由：就是交换机制将消息传递给队列的路径。

> 路由是交换机制`exchange`的一个属性，在此之前，默认和广播的`exchange`都把它忽略掉。
>
> 因为这两个的路由的固定的，前者传递到`routingKey`同名的队列上,后者传递到与`exchange`绑定的队列上

Direct exchange:翻译为直接交换，做的事情很简单，就是` binding key`和`routing key`一致，就会转发此消息

> `routing key` 在发送方发送消息是，可以指定
>
> ​	`channel.basicPublish(EXCHANGE_NAME, severity, null, message.getBytes("UTF-8"));`
>
> `binding key`在接收方将队列绑定`exchange`上时可以指定
>
> ​	`channel.queueBind(queueName, EXCHANGE_NAME, bindingKey);`











**内部实现内，消息是如何路由到指定的队列呢？**

如果发送的`routing`和绑定在`exchange`的队列的`routing`是一样的，就是目标广播对象

绑定在`exchange`的队列的`routing`也叫`binding key`

大致理解了概念，就开始码代码吧：

发送端：基本跟广播的发送端一样，只不过在发送时，要指定一个`routing`，以指定目标广播对象

>  channel.basicPublish(EXCHANGE_NAME, severity, null, message.getBytes("UTF-8"));
>
> 第二个参数，就是`routing`了

接受端：基本和广播的接受端一样，只不过在将队列和`exchange`绑定在一起时，要加一个`binding key`

这样`exchange`就可以根据消息的`routing`,找到目标队列了

> 指的一提的是，一个队列可以在`exchange`绑定多个`binding key`
>
> 这样可以收到更多感兴趣的广播



唔，要不要再啰嗦几句？

本节的内容其实是订阅-发布模型的一个进化，如果说订阅-发布模型是村广播

那么路由这章的内容就是家庭广播了

这节内容可能会和HelloWorld那节有点相似，列一下相同点？

相同点

1. 都是在发送方在发送消息时，要指定routing
2. 都有特定的消费者
3. 路由算法都是通过routing，来找特定的名称，找到目标通讯队列的

但是有不同之处

1. 前面提到的，都有特定的消费者，但是HelloWorld是一个消息只能有一个消费者，路由是一个消息有多个消费者

2. 前面提到的“路由算法都是通过routing，来找特定的名称，找到目标通讯队列的

   找的算法还不一样，HelloWorld是找队列名匹配的，路由是找bindingKey的
> 由此可见，不能把routing简单的认为是队列名，队列名只是其中的一类罢了

3. 还有使用的队列属性不一样，交换机制也不一样。

好啦，啰嗦完毕



#### 3.5 话题（Topics）

上一节我们将消息广播到某些特定的队列里面。其做法是在消息发送时指定routingKey

看上去比订阅-发布模型先进了一点。

但是还是有不足，就是消息发送时只能指定一个`routingKey`，只能发送给指定的队列

> 相当于信息只能有一个属性，这不适用于某些特殊业务。

那么，你以为我要讲解发送多个routingKey的情况？

然而并不是.虽然这样做我觉得更合理一点。。

好吧，言归正传。这次话题这一章，生产者发送消息依然只能用一个routingKey

只不过跟其他的章节相比，它多了几个特点

1. 生产者发送消息的routingKey 可以带`.`号了,    这个`.`号两边是单词来着

2. 使用的`exchange`类型变了，变成了`Topics`

3. 消费者绑定在`exchange`的`bindingKey`可以带通配符了。

   `*`号代表一个单词

   `#` 号代表0个或者多个单词

那么问题来了，`Topics`类型的`exchange`是如何路由到特定的队列的呢？

还是用routingKey和bindingKey做匹配来确认的。

不过这次支持模糊匹配罢了

怎么模糊匹配的？

介绍几种情况

1. `routingKey` 填`xxxx` 

   `bindingKey`填`xxxx` 

   结果：匹配

   > 其实就是前面介绍的路由应用了

2. `routingKey` 填`xxxx`

   `bindingKey` 填`#` 

   结果：匹配

> 就是订阅-发布模型了

1. `routingKey` 填`abc.xxxx`

   `bindingKey` 填`abc.*` 

   结果：匹配

> 就是传说的模糊匹配了

但是不要以为routingKey的每一个单词，都算一个routingKey

并不是，请查看下面的反例

1. `routingKey` 填`abc.xxxx`

   `bindingKey` 填`abc` 

   结果：不匹配

1. `routingKey` 填`abc.xxxx`

   `bindingKey` 填`*` 

   结果：不匹配,    `*`只能匹配一个单词，但是routingKey有两个单词

PS:代码已经放到`com.cxh.topics`里面了

#### 3.6  RPC

想不到吧，RabbitMq还能远程调用啊哈哈哈哈

但是，私以为，就算能远程调用，信息也得转过两手

二手消息，要不？

言归正传，这次真的是要用RabbitMq实现一个RPC调用链

特别之处有几个

1. 这次使用的`exchange`类型是默认类型。也就是说，会根据routingKey寻找对应的队列名，发送消息

2. 无生产者和消费者之分，而是客户端和服务端之分。

   客户端负责请求，服务端进行处理，服务端处理后，再返回数据给客户端

   客户端类似于生产者，服务端类似于消费者。

   但是消费者还会向生产者反馈消息，以往的章节没有涉及到这一点。

   这是RPC模式和其他传统消息队列模式的最大不同

3. 好像就这样了

接下来来谈谈几个问题

1. 官网提供的客户端代码并没有他所声称的`每一个客户端都使用一个队列，而不是每次请求都创建一个队列`

   实际上，从git示例代码看过来，是每次请求都会创建一个队列

   > 我问过他们了，他们承认了，并且说提供的示例的最基本的示例，所以没有包含教程所有提到的东西

   所以呢？我就开始改，把代码改成每一个客户端，都使用同一个案例，在改的过程中，发现一些有趣的东西。

   > 不涉及内部实现，只是记录一些有趣的现象而已

   1. 在方法内部设置一个监听线程，当方法结束后，如果监听线程还存活，则方法内的一些变量它依然还可以访问到

      > 刚开始发现这个现象时简直跟见了鬼似的，尼玛方法结束了，可我还是能看到这个方法死亡之前的一些局部变量。。。这不是见鬼这是什么

   2. 自动删除的队列，当消费者取消时，队列就会自动删除
    但是非自动删除的队列，当消费者取消时，不会删除队列，而是取消监听程序

基本也就是这样了,再说说工作原理吧.
第一步:
客户端(生产者)---------(请求信息,回调对列名,请求标识ID)-------------->RabbitMq(rpc队列)

服务端从rpc队列取得数据
服务端处理请求中....
服务端提取请求信息的回调对列名....

第二步:
服务端(消费者)---------(响应信息,请求标识ID)-------------->RabbitMq(回调队列)

第三步:
客户端从回调队列取得数据
关闭监听队列通道
返回给调用方













### 3.2 插件

RabbitMq如果你仅仅只是启动服务端，那么它的功能很单一，就是一个消息队列的服务器，充当一个消息的中转站。为了获取更多功能，添加各种特性，你就需要启动插件

现在开始逐一介绍下RabbitMq的一些插件

#### 3.2.1 管理插件

这个插件提供命令行工具和HttpAPi,用于监控和管理RabbitMq的节点和集群。

还有浏览器的UI，可以方便查看

首先启用它

`rabbitmq-plugins enable rabbitmq_management`

> 插件激活后不需要重启节点

启动完毕后，默认情况下，可以通过以下地址访问到浏览器的UI管理端

` http://localhost:15672/`

> 如果是在本地访问的话。。

如果想访问这个浏览器UI，你需要一个用户，可以使用一开始的`guest`

也可以新建一个用户，默认情况下，添加的用户没有用户标记

> 需要特定的标记，用户才能允许访问这个浏览器UI

关于如何新建用户，以及设置用户标记，先挖坑。。



其他的功能就大致略一下

有HTTP API 的TLS配置

超时配置

响应压缩

还有介绍UI界面上都是些什么东西

如何跨域请求

会话超时设置











### 3.3 RabbitMq的一些命令行

`sudo rabbitmqctl list_queues`  用于查看当前服务器有多少个队列



`sudo rabbitmqctl list_exchanges`  列出服务器支持哪些交换机制



`rabbitmqctl list_bindings`   列出队列和`exchange`的绑定列表





### 3.4 RabbitMq的用户体系

先挖坑了，可能填，可能不填。









# 三：RabbitMQ的应用

目标：实现一个高可用的服务器，支持多并发，并将并发请求压入到队列中

等到并发请求执行完毕，返回一个响应



